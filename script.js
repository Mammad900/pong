/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./math.ts":
/*!*****************!*\
  !*** ./math.ts ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   constrain: () => (/* binding */ constrain),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   v2add: () => (/* binding */ v2add),\n/* harmony export */   v2angle: () => (/* binding */ v2angle),\n/* harmony export */   v2cross: () => (/* binding */ v2cross),\n/* harmony export */   v2dist: () => (/* binding */ v2dist),\n/* harmony export */   v2div: () => (/* binding */ v2div),\n/* harmony export */   v2dot: () => (/* binding */ v2dot),\n/* harmony export */   v2isInAreaCS: () => (/* binding */ v2isInAreaCS),\n/* harmony export */   v2isInAreaTLBR: () => (/* binding */ v2isInAreaTLBR),\n/* harmony export */   v2isParallel: () => (/* binding */ v2isParallel),\n/* harmony export */   v2lerp: () => (/* binding */ v2lerp),\n/* harmony export */   v2mag: () => (/* binding */ v2mag),\n/* harmony export */   v2mul: () => (/* binding */ v2mul),\n/* harmony export */   v2normalize: () => (/* binding */ v2normalize),\n/* harmony export */   v2project: () => (/* binding */ v2project),\n/* harmony export */   v2random: () => (/* binding */ v2random),\n/* harmony export */   v2reflect: () => (/* binding */ v2reflect),\n/* harmony export */   v2rotate: () => (/* binding */ v2rotate),\n/* harmony export */   v2slope: () => (/* binding */ v2slope),\n/* harmony export */   v2sub: () => (/* binding */ v2sub)\n/* harmony export */ });\n/**\n * Adds two vectors component-wise.\n */\nfunction v2add([x1, y1], [x2, y2]) {\n    return [x1 + x2, y1 + y2];\n}\n/**\n * Subtracts one vector from another component-wise.\n */\nfunction v2sub([x1, y1], [x2, y2]) {\n    return [x1 - x2, y1 - y2];\n}\n/**\n * Multiplies a vector by another vector component-wise or by a scalar.\n */\nfunction v2mul([x1, y1], b) {\n    if (Array.isArray(b)) {\n        const [x2, y2] = b;\n        return [x1 * x2, y1 * y2];\n    }\n    else\n        return [x1 * b, y1 * b];\n}\n/**\n * Divides a vector by another vector component-wise or by a scalar.\n */\nfunction v2div([x1, y1], b) {\n    if (Array.isArray(b)) {\n        const [x2, y2] = b;\n        return [x1 / x2, y1 / y2];\n    }\n    else\n        return [x1 / b, y1 / b];\n}\n/**\n * Computes the magnitude (length) of a vector.\n */\nfunction v2mag(a) {\n    return Math.hypot(...a);\n}\n/**\n * Normalizes a vector (scales it to have a length of 1).\n */\nfunction v2normalize(a) {\n    return v2div(a, v2mag(a));\n}\n/**\n * Rotates a vector counterclockwise by a given angle (in radians).\n */\nfunction v2rotate([x, y], angle) {\n    return [\n        x * Math.cos(angle) - y * Math.sin(angle),\n        x * Math.sin(angle) + y * Math.cos(angle)\n    ];\n}\n/**\n * Computes the dot product of two vectors.\n */\nfunction v2dot([x1, y1], [x2, y2]) {\n    return x1 * x2 + y1 * y2;\n}\n/**\n * Computes the distance between two points (vectors).\n */\nfunction v2dist(a, b) {\n    return v2mag(v2sub(a, b));\n}\n/**\n * Linearly interpolates between two vectors by factor t (0 to 1).\n */\nfunction v2lerp(a, b, t) {\n    return v2add(v2mul(a, 1 - t), v2mul(b, t));\n}\n/**\n * Computes the angle (in radians) between two vectors.\n */\nfunction v2angle(a, b) {\n    return Math.acos(v2dot(a, b) / (v2mag(a) * v2mag(b)));\n}\n/**\n * Projects vector `a` onto vector `b`.\n */\nfunction v2project(a, b) {\n    return v2mul(b, v2dot(a, b) / v2dot(b, b));\n}\n/**\n * Computes the cross product of two 2D vectors (scalar result).\n */\nfunction v2cross([x1, y1], [x2, y2]) {\n    return x1 * y2 - x2 * y1;\n}\n/**\n * Computes the slope (y/x) of a vector.\n */\nfunction v2slope([x, y]) {\n    return y / x;\n}\n/**\n * Checks if two vectors are parallel (same slope).\n */\nfunction v2isParallel(a, b) {\n    return v2slope(a) == v2slope(b);\n}\n/**\n * Reflects vector `d` across a given normal.\n */\nfunction v2reflect(d, normal) {\n    return v2sub(d, v2mul(normal, v2dot(d, normal) * 2));\n}\n/**\n * Generates a random vector within the given min/max bounds.\n */\nfunction v2random(min, max) {\n    return [\n        random(min[0], max[0]),\n        random(min[1], max[1]),\n    ];\n}\n/**\n * Checks if a target point is inside a rectangular area defined by top-left and bottom-right corners.\n * The padding expands the area outwards.\n */\nfunction v2isInAreaTLBR(target, topLeft, bottomRight, padding = 0) {\n    return (target[0] >= topLeft[0] - padding &&\n        target[0] <= bottomRight[0] + padding &&\n        target[1] >= topLeft[1] - padding &&\n        target[1] <= bottomRight[1] + padding);\n}\n/**\n * Checks if a target point is inside a rectangular area defined by center and size.\n * The padding expands the area outwards.\n */\nfunction v2isInAreaCS(target, center, size, padding = 0) {\n    const halfSize = v2div(size, 2);\n    return (target[0] >= center[0] - halfSize[0] - padding &&\n        target[0] <= center[0] + halfSize[0] + padding &&\n        target[1] >= center[1] - halfSize[1] - padding &&\n        target[1] <= center[1] + halfSize[1] + padding);\n}\n/**\n * Generates a random integer within the given min/max range.\n */\nfunction random(min, max) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\n * Constrains a number within a given range.\n */\nfunction constrain(input, min, max) {\n    return input < min ? min : input > max ? max : input;\n}\n//@ts-ignore\nNumber.prototype.mod = function (n) {\n    //@ts-ignore\n    return ((this % n) + n) % n;\n};\n\n\n//# sourceURL=webpack:///./math.ts?");

/***/ }),

/***/ "./script.ts":
/*!*******************!*\
  !*** ./script.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ \"./math.ts\");\n// Originally developed by @amir-kht\n// Refactored and improved by @Mammad900\n\nlet canvas = document.querySelector(\"canvas\");\nlet gameSize = [canvas.width = document.body.clientWidth, canvas.height = document.body.clientHeight];\nlet ctxMain = canvas.getContext(\"2d\");\nlet ctx = new OffscreenCanvas(...gameSize).getContext('2d');\n//#region Constants\nconst debug = 1;\nconst frameSample = 10;\nconst ballRadiusDefault = 10;\nconst defaultBallSpeed = [7, 3];\nconst paddleSize = [10, 200], paddleMargin = 20;\nconst comboMinSpeed = 25, maxCombo = 3, comboHitSize = 0.5;\nconst boomMessageTime = 1000;\nconst hitAccel = [1.2, 1.05], maxBallDeflect = Math.PI / 12;\nconst boomAccel = [2, 1.6];\nconst dropChance = 0.001, dropSize = [20, 50], crazyDropChance = 0.25;\n//#endregion\n//#region Game State\nlet paddle1Pos = [paddleMargin, gameSize[1] / 2];\nlet paddle1Height = paddleSize[1];\nlet paddle2Pos = [gameSize[0] - paddleMargin, gameSize[1] / 2];\nlet paddle2Height = paddleSize[1];\nlet ballRadius = ballRadiusDefault;\nlet ballPos;\nlet ballSpeed;\nlet paddle1Speed = 0, paddle2Speed = 0;\nlet score1 = 0, score2 = 0;\nlet goodHit1 = 0, goodHit2 = 0;\nlet lastBoom = 0;\nlet drops = [];\nlet gravity = 0; // positive: down, negative: up\nlet enableWalls = true;\nlet lastHitDrop = \"\", lastHitDropType = \"normal\", lastHitDropOpen = false;\nlet activityThisRound = false;\n//#endregion\nlet lastFrame = Date.now();\nctxMain.globalCompositeOperation = \"lighter\";\nctxMain.globalAlpha = 2 / frameSample;\nfunction resetBall() {\n    ballRadius = ballRadiusDefault;\n    paddle1Height = paddle2Height = paddleSize[1];\n    ballPos = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2div)(gameSize, 2);\n    ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(defaultBallSpeed, [Math.random() > 0.5 ? -1 : 1, Math.random() > 0.5 ? -1 : 1]);\n    gravity = 0;\n    enableWalls = true;\n    goodHit1 = goodHit2 = lastBoom = 0;\n    activityThisRound = false;\n}\nresetBall();\nfunction resetEverything() {\n    resetSize();\n    score1 = score2 = 0;\n    drops = [];\n    resetBall();\n}\nfunction resetSize() {\n    gameSize = [canvas.width = ctx.canvas.width = document.body.clientWidth, canvas.height = ctx.canvas.height = document.body.clientHeight];\n    paddle1Pos = [paddleMargin, gameSize[1] / 2];\n    paddle2Pos = [gameSize[0] - paddleMargin, gameSize[1] / 2];\n}\n// Called every frame\nfunction frame() {\n    const now = Date.now();\n    const d = Math.min(now - lastFrame, 30) / frameSample; // dont jump too much when not being rendered\n    lastFrame = now;\n    ctxMain.clearRect(0, 0, canvas.width, canvas.height);\n    for (let i = 0; i < frameSample; i++) {\n        update(d);\n        draw();\n        ctxMain.drawImage(ctx.canvas, 0, 0);\n    }\n    requestAnimationFrame(frame);\n}\nfunction update(Δt) {\n    Δt /= 16; // Speed calculations were originally designed for 60Hz (16ms between frames). This is to compensate.\n    //#region Add drops\n    if (Math.random() < Δt * dropChance * (0.5 + goodHit1 + goodHit2) && drops.length < 5) {\n        const r = (0,_math__WEBPACK_IMPORTED_MODULE_0__.random)(dropSize[0], dropSize[1]);\n        drops.push({\n            pos: (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2random)([gameSize[0] / 4 + r, r], [gameSize[0] * 0.75 - r, gameSize[1] - r]),\n            speed: [Math.random() * 1 - 1, Math.random() * 1 - 1],\n            r,\n            isCrazy: Math.random() < crazyDropChance\n        });\n    }\n    //#endregion\n    //#region Check collision with left paddle\n    function collision1(n, paddleScale = 1) {\n        // return ballPos[1] > (paddle1Pos[1]+n*gameSize[1]) - paddle1Height / 2 &&\n        //        ballPos[1] < (paddle1Pos[1]+n*gameSize[1]) + paddle1Height / 2\n        return (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2isInAreaCS)(ballPos, (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2add)(paddle1Pos, [0, n * gameSize[1]]), [paddleSize[0], paddle1Height * paddleScale], ballRadius);\n    }\n    if (ballSpeed[0] < 0 &&\n        // ballPos[0] - ballRadius < paddle1Pos[0] &&\n        (collision1(-1) || collision1(0) || collision1(1))) {\n        if (goodHit1 == 0) {\n            updateHUD();\n        }\n        ballCollision(paddle1Speed);\n        // A good hit is when the ball hits the center of the paddle \n        if ((collision1(-1, 0.5) || collision1(0, 0.5) || collision1(1, 0.5)) &&\n            (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mag)(ballSpeed) >= comboMinSpeed) {\n            goodHit1++;\n            updateHUD();\n            comboHUD('r');\n            if (goodHit1 == maxCombo) { // BOOM!\n                ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, boomAccel);\n                lastBoom = Date.now();\n                setTimeout(() => {\n                    goodHit1 = Math.max(goodHit1 - maxCombo, 0);\n                    updateHUD();\n                }, boomMessageTime);\n            }\n        }\n        else {\n            goodHit1 = 0;\n            updateHUD();\n        }\n    }\n    else if (ballSpeed[0] < 0 && ballPos[0] < 0) { // Goal\n        if (activityThisRound) {\n            score2++;\n            scoreHUD(2);\n        }\n        goodHit1 = goodHit2 = 0;\n        updateHUD();\n        resetBall();\n    }\n    //#endregion\n    //#region Check collision with right paddle\n    function collision2(n, paddleScale = 1) {\n        // return ballY > (paddle2Y+n*gameHeight) - paddle2Height / 2 &&\n        //        ballY < (paddle2Y+n*gameHeight) + paddle2Height / 2\n        return (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2isInAreaCS)(ballPos, (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2add)(paddle2Pos, [0, n * gameSize[1]]), [paddleSize[0], paddle2Height * paddleScale], ballRadius);\n    }\n    if (ballSpeed[0] > 0 &&\n        // ballX + ballRadius > paddle2X &&\n        (collision2(-1) || collision2(0) || collision2(1))) {\n        if (goodHit2 == 0) {\n            updateHUD();\n        }\n        ballCollision(paddle2Speed);\n        // A good hit is when the ball hits the center of the paddle \n        if ((collision2(-1, 0.5) || collision2(0, 0.5) || collision2(1, 0.5)) &&\n            (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mag)(ballSpeed) >= comboMinSpeed) {\n            goodHit2++;\n            updateHUD();\n            comboHUD('b');\n            if (goodHit2 >= maxCombo) { // BOOM!\n                ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, boomAccel);\n                lastBoom = Date.now();\n                setTimeout(() => {\n                    goodHit2 = Math.max(goodHit2 - maxCombo, 0);\n                    updateHUD();\n                }, boomMessageTime);\n            }\n        }\n        else {\n            goodHit2 = 0;\n            updateHUD();\n        }\n    }\n    else if (ballSpeed[0] > 0 && ballPos[0] >= gameSize[0]) { // Goal\n        if (activityThisRound) {\n            score1++;\n            scoreHUD(1);\n        }\n        goodHit1 = goodHit2 = 0;\n        updateHUD();\n        resetBall();\n    }\n    //#endregion\n    //#region Collision with top and bottom\n    if ((ballPos[1] - ballRadius < 0 && ballSpeed[1] < 0)\n        || (ballPos[1] + ballRadius >= gameSize[1] - 10 && ballSpeed[1] > 0)) {\n        if (enableWalls)\n            ballSpeed[1] *= -1;\n        else\n            ballPos[1] = (ballPos[1] + gameSize[1]) % gameSize[1];\n    }\n    //#endregion\n    //#region Check Drops\n    let hitDrops = [];\n    for (const drop of drops) {\n        drop.pos = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2add)(drop.pos, (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(drop.speed, Δt));\n        // delete out of range drops\n        if ((0,_math__WEBPACK_IMPORTED_MODULE_0__.v2isInAreaTLBR)(drop.pos, [0, 0], gameSize, drop.r)) {\n            drop.delete = true;\n        }\n        const d = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2dist)(drop.pos, ballPos);\n        if (d < drop.r + ballRadius) { // Collision\n            hitDrops.push(drop);\n            if (drop.isCrazy) {\n                switch ((0,_math__WEBPACK_IMPORTED_MODULE_0__.random)(0, 1)) {\n                    case 0:\n                        gravity = Math.random() / 2 - 0.5;\n                        lastHitDrop = \"Gravity!\";\n                        break;\n                    case 1:\n                        enableWalls = false;\n                        lastHitDrop = \"No walls!\";\n                        break;\n                }\n                lastHitDropType = 'crazy';\n            }\n            else {\n                switch ((0,_math__WEBPACK_IMPORTED_MODULE_0__.random)(0, 8)) {\n                    case 0:\n                        ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, 2);\n                        lastHitDrop = \"2x Ball speed!\";\n                        break;\n                    case 1:\n                        ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, -1);\n                        lastHitDrop = \"Invert ball speed!\";\n                        break;\n                    case 2:\n                        ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, 0.5);\n                        lastHitDrop = \"Half ball speed!\";\n                        break;\n                    case 3:\n                        ballSpeed[1] *= 2;\n                        lastHitDrop = \"2x Vertical ball speed!\";\n                        break;\n                    case 4:\n                        paddle1Height /= 1.5;\n                        lastHitDrop = \"Red paddle shrink!\";\n                        break;\n                    case 5:\n                        paddle1Height *= 1.5;\n                        lastHitDrop = \"Red paddle grow!\";\n                        break;\n                    case 6:\n                        paddle2Height /= 1.5;\n                        lastHitDrop = \"Blue paddle shrink!\";\n                        break;\n                    case 7:\n                        paddle2Height *= 1.5;\n                        lastHitDrop = \"Blue paddle grow!\";\n                        break;\n                    case 8:\n                        ballRadius *= 2;\n                        lastHitDrop = \"Bigger ball!\";\n                        break;\n                    default:\n                        break;\n                }\n                lastHitDropType = 'normal';\n            }\n            lastHitDropOpen = true;\n            updateHUD();\n            setTimeout(() => {\n                lastHitDropOpen = false;\n                updateHUD();\n            }, 2000);\n            setTimeout(() => {\n                lastHitDrop = '';\n                updateHUD();\n            }, 2500);\n        }\n    }\n    drops = drops.filter(drop => (!hitDrops.includes(drop)) && (!drop.delete));\n    //#endregion\n    //#region Ball and paddle movement\n    ballSpeed[1] += gravity * Δt;\n    ballPos = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2add)(ballPos, (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, Δt));\n    if (enableWalls) {\n        paddle1Pos[1] = (0,_math__WEBPACK_IMPORTED_MODULE_0__.constrain)(paddle1Pos[1] + paddle1Speed * Δt, paddle1Height / 2, gameSize[1] - paddle1Height / 2);\n        paddle2Pos[1] = (0,_math__WEBPACK_IMPORTED_MODULE_0__.constrain)(paddle2Pos[1] + paddle2Speed * Δt, paddle2Height / 2, gameSize[1] - paddle2Height / 2);\n    }\n    else {\n        paddle1Pos[1] = (paddle1Pos[1] + paddle1Speed * Δt).mod(gameSize[1]);\n        paddle2Pos[1] = (paddle2Pos[1] + paddle2Speed * Δt).mod(gameSize[1]);\n    }\n    //#endregion\n}\nrequestAnimationFrame(frame);\nfunction ballCollision(paddleSpeed) {\n    if ((0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mag)(ballSpeed) < 30) { // Maximum speed is 30\n        ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, hitAccel);\n    }\n    ballSpeed[0] *= -1;\n    if (paddleSpeed * ballSpeed[1] < 0) {\n        ballSpeed[1] *= -1;\n    }\n    ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2rotate)(ballSpeed, Math.random() * maxBallDeflect);\n}\nfunction updateHUD() {\n    document.querySelector(\"#score-1\").innerHTML = score1.toString();\n    document.querySelector(\"#score-2\").innerHTML = score2.toString();\n    document.querySelector(\"#r\").innerHTML = goodHit1 === maxCombo ? \"BOOM!\" : goodHit1 === 0 ? \"\" : `Combo x${goodHit1}`;\n    document.querySelector(\"#b\").innerHTML = goodHit2 === maxCombo ? \"BOOM!\" : goodHit2 === 0 ? \"\" : `Combo x${goodHit2}`;\n    document.querySelector(\"#drop\").innerHTML = lastHitDrop;\n    document.querySelector(\"#drop\").className = `${lastHitDropType} ${lastHitDropOpen ? 'open' : ''}`;\n}\nfunction scoreHUD(player) {\n    const el = document.getElementById('score-' + player);\n    el.classList.add('bump');\n    setTimeout(() => {\n        el.classList.remove('bump');\n    }, 1000);\n}\nfunction comboHUD(player) {\n    const el = document.getElementById(player);\n    el.classList.add('bump');\n    setTimeout(() => {\n        el.classList.remove('bump');\n    }, 1000);\n}\nfunction draw() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    const boom1 = goodHit1 == maxCombo;\n    const boom2 = goodHit2 == maxCombo;\n    const boomPercent = lastBoom == 0 ? 0 : 1 - Math.min((Date.now() - lastBoom) / 1000, 1);\n    // Ball\n    ctx.fillStyle = \"white\";\n    ctx.shadowColor = lastBoom ? 'white' : 'transparent';\n    ctx.shadowBlur = 20;\n    function drawBall(pos) {\n        ctx.beginPath();\n        ctx.arc(...pos, ballRadius, 0, Math.PI * 2); // circle\n        ctx.fill();\n    }\n    drawBall(ballPos);\n    if (!enableWalls) {\n        drawBall((0,_math__WEBPACK_IMPORTED_MODULE_0__.v2add)(ballPos, [0, gameSize[1]]));\n        drawBall((0,_math__WEBPACK_IMPORTED_MODULE_0__.v2add)(ballPos, [0, -gameSize[1]]));\n    }\n    // Paddle 1\n    ctx.fillStyle = boom1 ? `rgb(255,${Math.floor(boomPercent * 255)},${Math.floor(boomPercent * 255)})` : 'red';\n    ctx.shadowColor = boom1 ? `rgba(255,0,0,${boomPercent})` : 'transparent';\n    ctx.fillRect(...(0,_math__WEBPACK_IMPORTED_MODULE_0__.v2sub)(paddle1Pos, [paddleSize[0], paddle1Height / 2]), paddleSize[0], paddle1Height);\n    if (!enableWalls) {\n        ctx.fillRect(...(0,_math__WEBPACK_IMPORTED_MODULE_0__.v2sub)(paddle1Pos, [paddleSize[0], paddle1Height / 2 - gameSize[1]]), paddleSize[0], paddle1Height);\n        ctx.fillRect(...(0,_math__WEBPACK_IMPORTED_MODULE_0__.v2sub)(paddle1Pos, [paddleSize[0], paddle1Height / 2 + gameSize[1]]), paddleSize[0], paddle1Height);\n    }\n    // Paddle 2\n    ctx.fillStyle = boom2 ? `rgb(${Math.floor(boomPercent * 255)},255,255)` : 'aqua';\n    ctx.shadowColor = boom2 ? `rgba(0,255,255,${boomPercent})` : 'transparent';\n    ctx.fillRect(...(0,_math__WEBPACK_IMPORTED_MODULE_0__.v2sub)(paddle2Pos, [0, paddle2Height / 2]), paddleSize[0], paddle2Height);\n    if (!enableWalls) {\n        ctx.fillRect(...(0,_math__WEBPACK_IMPORTED_MODULE_0__.v2sub)(paddle2Pos, [0, paddle2Height / 2 + gameSize[1]]), paddleSize[0], paddle2Height);\n        ctx.fillRect(...(0,_math__WEBPACK_IMPORTED_MODULE_0__.v2sub)(paddle2Pos, [0, paddle2Height / 2 - gameSize[1]]), paddleSize[0], paddle2Height);\n    }\n    // Drops\n    ctx.shadowColor = 'transparent';\n    for (const drop of drops) {\n        ctx.beginPath();\n        ctx.arc(...drop.pos, drop.r, 0, Math.PI * 2); // circle\n        ctx.fillStyle = drop.isCrazy ? \"red\" : \"gold\";\n        ctx.fill();\n    }\n}\ndocument.body.addEventListener('keydown', e => {\n    const paddleMaxSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.constrain)((0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mag)(ballSpeed), 10, 40); // Get speed vector magnitude, and make sure its no slower than 40 idkunits\n    if (e.key.toLowerCase() == \"w\") {\n        paddle1Speed = -(paddleMaxSpeed + Math.abs(ballPos[1] - paddle1Pos[1]) * 10 / gameSize[1]);\n        activityThisRound = true;\n    }\n    if (e.key.toLowerCase() == \"s\") {\n        paddle1Speed = +(paddleMaxSpeed + Math.abs(ballPos[1] - paddle1Pos[1]) * 10 / gameSize[1]);\n        activityThisRound = true;\n    }\n    if (e.key == 'ArrowUp') {\n        paddle2Speed = -(paddleMaxSpeed + Math.abs(ballPos[1] - paddle2Pos[1]) * 10 / gameSize[1]);\n        activityThisRound = true;\n    }\n    if (e.key == 'ArrowDown') {\n        paddle2Speed = +(paddleMaxSpeed + Math.abs(ballPos[1] - paddle2Pos[1]) * 10 / gameSize[1]);\n        activityThisRound = true;\n    }\n    if (e.key == '+' && debug) {\n        ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2mul)(ballSpeed, 2);\n    }\n    if (e.key == '-' && debug) {\n        ballSpeed = (0,_math__WEBPACK_IMPORTED_MODULE_0__.v2div)(ballSpeed, 2);\n    }\n    if (e.key == 'b' && debug) {\n        goodHit1 = maxCombo;\n        lastBoom = Date.now();\n        setTimeout(() => {\n            goodHit1 = Math.max(goodHit1 - maxCombo, 0);\n            updateHUD();\n        }, boomMessageTime);\n    }\n    if (e.key == 'd' && debug) {\n        goodHit2 = maxCombo;\n        lastBoom = Date.now();\n        setTimeout(() => {\n            goodHit2 = Math.max(goodHit2 - maxCombo, 0);\n            updateHUD();\n        }, boomMessageTime);\n    }\n});\ndocument.body.addEventListener('keyup', e => {\n    if (e.key.toLowerCase() == \"w\") {\n        paddle1Speed = 0;\n    }\n    if (e.key.toLowerCase() == \"s\") {\n        paddle1Speed = 0;\n    }\n    if (e.key == 'ArrowUp') {\n        paddle2Speed = 0;\n    }\n    if (e.key == 'ArrowDown') {\n        paddle2Speed = 0;\n    }\n});\ndocument.body.addEventListener('contextmenu', () => {\n    document.body.requestFullscreen();\n    screen.orientation.lock(\"landscape-primary\");\n    resetSize();\n    setTimeout(() => {\n        resetEverything();\n    }, 5000);\n});\ndocument.body.addEventListener('touchmove', e => {\n    for (const touch of e.changedTouches) {\n        if (touch.clientX / gameSize[0] < 0.25) {\n            paddle1Pos[1] = touch.clientY;\n        }\n        if (touch.clientX / gameSize[0] > 0.75) {\n            paddle2Pos[1] = touch.clientY;\n        }\n    }\n    draw();\n});\nwindow.addEventListener('resize', () => {\n    resetSize();\n});\n\n\n//# sourceURL=webpack:///./script.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./script.ts");
/******/ 	
/******/ })()
;